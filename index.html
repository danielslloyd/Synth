<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToneMatrix Clone</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background-color: #000; display: flex; min-height: 100vh; font-family: 'Helvetica Neue', Arial, sans-serif; overflow-x: auto; color: #fff; }

        .editor-panel { width: 300px; min-width: 300px; background: #0a0a0a; border-right: 1px solid #222; padding: 15px; overflow-y: auto; max-height: 100vh; }
        .editor-title { color: #00d4aa; font-size: 14px; font-weight: 500; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 15px; }
        .editor-section { margin-bottom: 20px; }
        .editor-section-title { color: #888; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        .instrument-list { display: flex; flex-direction: column; gap: 4px; margin-bottom: 10px; max-height: 250px; overflow-y: auto; }
        .instrument-item { display: flex; align-items: center; justify-content: space-between; padding: 8px; background: #1a1a1a; border-radius: 4px; cursor: pointer; font-size: 11px; }
        .instrument-item:hover { background: #2a2a2a; }
        .instrument-item.selected { background: #00d4aa; color: #000; }
        .instrument-item-actions { display: flex; gap: 4px; }
        .instrument-item-btn { background: transparent; border: none; color: inherit; cursor: pointer; padding: 2px; font-size: 10px; }
        .new-instrument-btn { width: 100%; padding: 8px; background: #1a1a1a; border: 1px dashed #444; border-radius: 4px; color: #888; cursor: pointer; font-size: 11px; }
        .new-instrument-btn:hover { border-color: #00d4aa; color: #00d4aa; }

        .wave-editor { background: #111; border-radius: 4px; padding: 10px; }
        .wave-type-selector { display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; margin-bottom: 10px; }
        .wave-type-btn { padding: 6px; background: #1a1a1a; border: 1px solid #333; border-radius: 3px; color: #888; cursor: pointer; font-size: 9px; text-transform: uppercase; }
        .wave-type-btn:hover { border-color: #00d4aa; color: #00d4aa; }
        .wave-type-btn.active { background: #00d4aa; border-color: #00d4aa; color: #000; }
        .wave-canvas-container { position: relative; margin-bottom: 10px; }
        .wave-canvas { width: 100%; height: 80px; background: #0a0a0a; border-radius: 3px; cursor: crosshair; }
        .wave-param { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 10px; }
        .wave-param label { color: #888; flex: 1; }
        .wave-param input[type="range"] { width: 100px; accent-color: #00d4aa; }
        .wave-param-value { color: #00d4aa; min-width: 35px; text-align: right; }
        .param-section { border-top: 1px solid #222; padding-top: 10px; margin-top: 10px; }
        .param-section-title { color: #666; font-size: 9px; text-transform: uppercase; margin-bottom: 8px; }

        .save-instruments-btn { width: 100%; padding: 10px; background: #00d4aa; border: none; border-radius: 4px; color: #000; cursor: pointer; font-size: 11px; font-weight: 500; margin-top: 10px; }
        .save-instruments-btn:hover { background: #00ffcc; }
        .load-instruments-btn { width: 100%; padding: 10px; background: #1a1a1a; border: 1px solid #00d4aa; border-radius: 4px; color: #00d4aa; cursor: pointer; font-size: 11px; margin-top: 5px; }
        .load-instruments-btn:hover { background: #00d4aa; color: #000; }

        .main-content { flex: 1; padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .title { color: #00d4aa; font-size: 20px; font-weight: 300; letter-spacing: 4px; text-transform: uppercase; }
        .controls { display: flex; gap: 15px; align-items: center; margin-bottom: 10px; }
        .btn { background: #1a1a1a; color: #00d4aa; border: 1px solid #00d4aa; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s ease; }
        .btn:hover { background: #00d4aa; color: #000; }
        .btn.active { background: #00d4aa; color: #000; }
        .tempo-control { display: flex; align-items: center; gap: 8px; color: #00d4aa; font-size: 12px; }
        .tempo-control select { background: #1a1a1a; color: #00d4aa; border: 1px solid #00d4aa; padding: 4px 8px; border-radius: 4px; cursor: pointer; }

        .grids-container { display: flex; flex-direction: column; gap: 15px; }
        .matrix-section { display: flex; flex-direction: column; gap: 4px; }
        .matrix-section.collapsed .matrix-wrapper, .matrix-section.collapsed .clone-buttons-row { display: none; }
        .matrix-section.muted { opacity: 0.5; }
        .matrix-header { display: flex; align-items: center; gap: 8px; padding-left: 7px; margin-bottom: 2px; }
        .instrument-select { background: #1a1a1a; color: #00d4aa; border: 1px solid #333; padding: 3px 6px; border-radius: 3px; font-size: 10px; cursor: pointer; }
        .track-btn { background: transparent; border: none; color: #666; cursor: pointer; font-size: 16px; padding: 2px; display: flex; align-items: center; justify-content: center; }
        .track-btn:hover { color: #00d4aa; }
        .track-btn.active { color: #00d4aa; }
        .track-btn .material-icons { font-size: 16px; }
        .remove-grid-btn { background: transparent; border: none; color: #666; cursor: pointer; font-size: 12px; padding: 2px 6px; }
        .remove-grid-btn:hover { color: #ff4444; }
        .matrix-wrapper { position: relative; padding: 6px; background: #0a0a0a; border-radius: 4px; }
        .matrix { display: grid; grid-template-columns: repeat(64, 1fr); gap: 1px; background: #111; padding: 1px; }
        .cell { width: 14px; height: 14px; background: #1a1a1a; border-radius: 1px; cursor: pointer; transition: all 0.05s ease; }
        .cell:hover { background: #2a2a2a; }
        .cell.active { background: var(--instrument-color, #00d4aa); box-shadow: 0 0 8px var(--instrument-color, #00d4aa), 0 0 15px var(--instrument-glow, rgba(0, 212, 170, 0.5)); }
        .cell.column-highlight { background: #2a2a2a; }
        .cell.active.column-highlight { background: var(--instrument-highlight, #00ffcc); box-shadow: 0 0 12px var(--instrument-highlight, #00ffcc), 0 0 20px var(--instrument-glow, rgba(0, 255, 204, 0.7)); }
        .cell.hover-highlight { background: #232323; }
        .cell.active.hover-highlight { filter: brightness(0.9); }

        .clone-buttons-row { display: flex; gap: 1px; padding-left: 7px; height: 14px; }
        .clone-btn { width: 14px; height: 14px; border: none; border-radius: 1px; cursor: pointer; font-size: 6px; font-weight: bold; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; background: var(--instrument-color, #00d4aa); color: #000; }
        .clone-btn:hover { transform: scale(1.1); }
        .clone-spacer { width: 14px; height: 14px; }
        .add-grid-btn { width: 100%; max-width: 200px; padding: 10px; background: #1a1a1a; border: 1px dashed #00d4aa; border-radius: 4px; color: #00d4aa; cursor: pointer; font-size: 14px; margin-top: 10px; }
        .add-grid-btn:hover { background: #00d4aa; color: #000; }
        .instructions { color: #444; font-size: 10px; text-align: center; }

        .grid-color-0 { --instrument-color: #00d4aa; --instrument-highlight: #00ffcc; --instrument-glow: rgba(0, 212, 170, 0.5); }
        .grid-color-1 { --instrument-color: #d400aa; --instrument-highlight: #ff00cc; --instrument-glow: rgba(212, 0, 170, 0.5); }
        .grid-color-2 { --instrument-color: #d4aa00; --instrument-highlight: #ffcc00; --instrument-glow: rgba(212, 170, 0, 0.5); }
        .grid-color-3 { --instrument-color: #00aad4; --instrument-highlight: #00ccff; --instrument-glow: rgba(0, 170, 212, 0.5); }
        .grid-color-4 { --instrument-color: #aa00d4; --instrument-highlight: #cc00ff; --instrument-glow: rgba(170, 0, 212, 0.5); }
        .grid-color-5 { --instrument-color: #d45500; --instrument-highlight: #ff7722; --instrument-glow: rgba(212, 85, 0, 0.5); }

        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .modal { background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 20px; max-width: 300px; }
        .modal-title { color: #00d4aa; font-size: 14px; margin-bottom: 15px; }
        .modal-text { color: #888; font-size: 12px; margin-bottom: 15px; }
        .modal-input { width: 100%; padding: 8px; background: #0a0a0a; border: 1px solid #333; border-radius: 4px; color: #fff; font-size: 11px; margin-bottom: 15px; }
        .modal-buttons { display: flex; gap: 10px; }
        .modal-btn { flex: 1; padding: 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; }
        .modal-btn-primary { background: #00d4aa; color: #000; }
        .modal-btn-secondary { background: #333; color: #fff; }
        .modal-btn:hover { opacity: 0.8; }
    </style>
</head>
<body>
    <div class="editor-panel">
        <div class="editor-title">Instruments</div>
        <div class="editor-section">
            <div class="editor-section-title">Library</div>
            <div class="instrument-list" id="instrumentList"></div>
            <button class="new-instrument-btn" id="newInstrumentBtn">+ New Instrument</button>
        </div>
        <div class="editor-section" id="waveEditorSection" style="display: none;">
            <div class="editor-section-title">Wave Editor</div>
            <div class="wave-editor">
                <input type="text" id="instrumentName" placeholder="Instrument name" style="width: 100%; padding: 6px; background: #1a1a1a; border: 1px solid #333; border-radius: 3px; color: #fff; font-size: 11px; margin-bottom: 10px;">

                <div class="wave-type-selector">
                    <button class="wave-type-btn" data-type="sine">Sine</button>
                    <button class="wave-type-btn" data-type="square">Square</button>
                    <button class="wave-type-btn" data-type="triangle">Triangle</button>
                    <button class="wave-type-btn" data-type="sawtooth">Sawtooth</button>
                    <button class="wave-type-btn" data-type="pulse">Pulse</button>
                    <button class="wave-type-btn" data-type="noise">Noise</button>
                    <button class="wave-type-btn" data-type="custom">Custom</button>
                    <button class="wave-type-btn" data-type="fm">FM</button>
                </div>

                <div class="wave-canvas-container">
                    <canvas class="wave-canvas" id="waveCanvas" width="260" height="80"></canvas>
                </div>

                <div id="pulseParams" style="display: none;">
                    <div class="wave-param">
                        <label>Duty Cycle</label>
                        <input type="range" id="dutyCycle" min="10" max="90" value="50">
                        <span class="wave-param-value" id="dutyCycleValue">50%</span>
                    </div>
                </div>

                <div id="fmParams" style="display: none;">
                    <div class="param-section-title">FM Synthesis</div>
                    <div class="wave-param">
                        <label>Mod Ratio</label>
                        <input type="range" id="fmRatio" min="1" max="16" value="2">
                        <span class="wave-param-value" id="fmRatioValue">2</span>
                    </div>
                    <div class="wave-param">
                        <label>Mod Depth</label>
                        <input type="range" id="fmDepth" min="0" max="1000" value="100">
                        <span class="wave-param-value" id="fmDepthValue">100</span>
                    </div>
                </div>

                <div class="param-section">
                    <div class="param-section-title">Noise</div>
                    <div class="wave-param">
                        <label>Amount</label>
                        <input type="range" id="noiseAmount" min="0" max="100" value="0">
                        <span class="wave-param-value" id="noiseAmountValue">0%</span>
                    </div>
                </div>

                <div class="param-section">
                    <div class="param-section-title">Envelope</div>
                    <div class="wave-param">
                        <label>Attack</label>
                        <input type="range" id="attack" min="1" max="100" value="10">
                        <span class="wave-param-value" id="attackValue">10ms</span>
                    </div>
                    <div class="wave-param">
                        <label>Decay</label>
                        <input type="range" id="decay" min="50" max="1000" value="300">
                        <span class="wave-param-value" id="decayValue">300ms</span>
                    </div>
                    <div class="wave-param">
                        <label>Volume</label>
                        <input type="range" id="volume" min="1" max="100" value="50">
                        <span class="wave-param-value" id="volumeValue">50%</span>
                    </div>
                </div>

                <button class="save-instruments-btn" id="saveInstrumentBtn">Save Instrument</button>
            </div>
        </div>
        <div class="editor-section">
            <button class="save-instruments-btn" id="exportInstrumentsBtn">Export All</button>
            <button class="load-instruments-btn" id="importInstrumentsBtn">Import</button>
            <input type="file" id="importFile" accept=".json" style="display: none;">
        </div>
    </div>
    <div class="main-content">
        <h1 class="title">ToneMatrix</h1>
        <div class="controls">
            <button class="btn" id="playBtn">Play</button>
            <button class="btn" id="clearBtn">Clear All</button>
            <div class="tempo-control">
                <label for="tempo">BPM:</label>
                <select id="tempo">
                    <option value="30">30</option>
                    <option value="60">60</option>
                    <option value="90">90</option>
                    <option value="120" selected>120</option>
                    <option value="150">150</option>
                    <option value="180">180</option>
                </select>
            </div>
        </div>
        <div class="grids-container" id="gridsContainer"></div>
        <button class="add-grid-btn" id="addGridBtn">+ Add Track</button>
        <p class="instructions">Click cells to create music. Use the panel to create custom instruments.</p>
    </div>
    <div class="modal-overlay" id="saveModal" style="display: none;">
        <div class="modal">
            <div class="modal-title" id="saveModalTitle">Save As New</div>
            <div class="modal-text" id="saveModalText">Enter a name for this instrument:</div>
            <input type="text" class="modal-input" id="saveAsName" placeholder="New name">
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-secondary" id="cancelSaveBtn">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="confirmSaveBtn">Save</button>
            </div>
        </div>
    </div>
    <script>
        let audioContext, isPlaying = false, currentColumn = 0, intervalId = null, tempo = 120;
        const ROWS = 16, COLS = 64;
        const grids = [];
        let gridCounter = 0;
        let hoveredColumn = -1;

        const frequencies = [
            1318.51, 1174.66, 1046.50, 880.00, 783.99, 659.26, 587.33, 523.25,
            440.00, 392.00, 329.63, 293.66, 261.63, 220.00, 196.00, 164.81
        ];

        let customWaveform = null;
        let isDrawing = false;
        let paintMode = null;
        let paintGridIndex = null;

        // Combined presets from both versions
        let instruments = [
            // Basic waveforms (from old version)
            { id: 'square', name: 'Square', type: 'square', noiseAmount: 0, attack: 10, decay: 300, volume: 50, isPreset: true },
            { id: 'sine', name: 'Sine', type: 'sine', noiseAmount: 0, attack: 10, decay: 300, volume: 50, isPreset: true },
            { id: 'triangle', name: 'Triangle', type: 'triangle', noiseAmount: 0, attack: 10, decay: 300, volume: 60, isPreset: true },
            { id: 'sawtooth', name: 'Sawtooth', type: 'sawtooth', noiseAmount: 0, attack: 10, decay: 300, volume: 30, isPreset: true },
            // Additional waveforms
            { id: 'pulse', name: 'Pulse', type: 'pulse', dutyCycle: 25, noiseAmount: 0, attack: 10, decay: 300, volume: 50, isPreset: true },
            { id: 'noise', name: 'Noise', type: 'noise', noiseAmount: 0, attack: 1, decay: 100, volume: 50, isPreset: true },
            // FM synths (from new version)
            { id: 'fm-bell', name: 'FM Bell', type: 'fm', fmRatio: 5, fmDepth: 200, noiseAmount: 0, attack: 5, decay: 500, volume: 40, isPreset: true },
            { id: 'fm-bass', name: 'FM Bass', type: 'fm', fmRatio: 1, fmDepth: 300, noiseAmount: 0, attack: 5, decay: 200, volume: 60, isPreset: true },
            // Other synths (from new version)
            { id: 'pad', name: 'Soft Pad', type: 'sine', noiseAmount: 5, attack: 50, decay: 800, volume: 40, isPreset: true },
            { id: 'pluck', name: 'Pluck', type: 'triangle', noiseAmount: 10, attack: 2, decay: 150, volume: 55, isPreset: true },
            { id: 'organ', name: 'Organ', type: 'square', noiseAmount: 0, attack: 10, decay: 400, volume: 45, isPreset: true },
            // Drums (from new version)
            { id: 'kick', name: 'Kick Drum', type: 'drum-kick', noiseAmount: 0, attack: 1, decay: 150, volume: 80, isPreset: true },
            { id: 'snare', name: 'Snare Drum', type: 'drum-snare', noiseAmount: 0, attack: 1, decay: 100, volume: 70, isPreset: true },
            { id: 'hihat', name: 'Hi-Hat', type: 'drum-hihat', noiseAmount: 0, attack: 1, decay: 50, volume: 50, isPreset: true },
            { id: 'clap', name: 'Clap', type: 'drum-clap', noiseAmount: 0, attack: 1, decay: 80, volume: 60, isPreset: true },
            { id: 'tom', name: 'Tom', type: 'drum-tom', noiseAmount: 0, attack: 1, decay: 120, volume: 65, isPreset: true }
        ];

        let selectedInstrumentId = null, editingInstrument = null;
        const cloneConfigs = [{ cols: 4, col: 3 }, { cols: 8, col: 7 }, { cols: 16, col: 15 }];
        const gridColors = ['grid-color-0', 'grid-color-1', 'grid-color-2', 'grid-color-3', 'grid-color-4', 'grid-color-5'];

        function init() {
            loadInstruments();
            renderInstrumentList();
            addGrid();
            setupEventListeners();
            setupWaveCanvas();
        }

        function addGrid() {
            const gridIndex = gridCounter++;
            const colorClass = gridColors[grids.length % gridColors.length];
            grids.push({
                index: gridIndex,
                data: Array(ROWS).fill(null).map(() => Array(COLS).fill(false)),
                instrumentId: 'square',
                colorClass: colorClass,
                muted: false,
                collapsed: false
            });
            renderGrid(gridIndex, colorClass);
        }

        function renderGrid(gridIndex, colorClass) {
            const container = document.getElementById('gridsContainer');
            const grid = grids.find(g => g.index === gridIndex);
            const section = document.createElement('div');
            section.className = `matrix-section ${colorClass}`;
            section.id = `section-${gridIndex}`;

            const header = document.createElement('div');
            header.className = 'matrix-header';

            // Collapse button
            const collapseBtn = document.createElement('button');
            collapseBtn.className = 'track-btn';
            collapseBtn.innerHTML = '<span class="material-icons">expand_more</span>';
            collapseBtn.title = 'Collapse/Expand';
            collapseBtn.id = `collapse-${gridIndex}`;
            collapseBtn.addEventListener('click', () => toggleCollapse(gridIndex));
            header.appendChild(collapseBtn);

            // Mute button
            const muteBtn = document.createElement('button');
            muteBtn.className = 'track-btn';
            muteBtn.innerHTML = '<span class="material-icons">volume_up</span>';
            muteBtn.title = 'Mute';
            muteBtn.id = `mute-${gridIndex}`;
            muteBtn.addEventListener('click', () => toggleMute(gridIndex));
            header.appendChild(muteBtn);

            // Clear track button
            const clearBtn = document.createElement('button');
            clearBtn.className = 'track-btn';
            clearBtn.innerHTML = '<span class="material-icons">deselect</span>';
            clearBtn.title = 'Clear track';
            clearBtn.addEventListener('click', () => clearTrack(gridIndex));
            header.appendChild(clearBtn);

            const select = document.createElement('select');
            select.className = 'instrument-select';
            select.id = `instrument-select-${gridIndex}`;
            updateInstrumentSelect(select, grid.instrumentId);
            select.addEventListener('change', (e) => { grid.instrumentId = e.target.value; });
            header.appendChild(select);

            if (grids.length > 1) {
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-grid-btn';
                removeBtn.textContent = '×';
                removeBtn.title = 'Remove track';
                removeBtn.addEventListener('click', () => removeGrid(gridIndex));
                header.appendChild(removeBtn);
            }

            section.appendChild(header);

            const wrapper = document.createElement('div');
            wrapper.className = 'matrix-wrapper';
            const matrix = document.createElement('div');
            matrix.className = 'matrix';
            matrix.id = `matrix-${gridIndex}`;

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.grid = gridIndex;
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    cell.addEventListener('mousedown', (e) => {
                        paintGridIndex = gridIndex;
                        paintMode = !grid.data[row][col];
                        setCell(gridIndex, row, col, cell, paintMode);
                    });
                    cell.addEventListener('mouseenter', (e) => {
                        if (e.buttons === 1 && paintGridIndex === gridIndex) {
                            setCell(gridIndex, row, col, cell, paintMode);
                        }
                        highlightColumn(col);
                    });
                    cell.addEventListener('mouseleave', () => {
                        clearColumnHighlight();
                    });
                    matrix.appendChild(cell);
                }
            }

            wrapper.appendChild(matrix);
            section.appendChild(wrapper);

            // Clone buttons row below grid
            const cloneRow = document.createElement('div');
            cloneRow.className = 'clone-buttons-row';
            for (let col = 0; col < COLS; col++) {
                const config = cloneConfigs.find(c => c.col === col);
                if (config) {
                    const btn = document.createElement('button');
                    btn.className = 'clone-btn';
                    btn.textContent = config.cols;
                    btn.title = `Clone first ${config.cols} columns`;
                    btn.addEventListener('click', () => clonePattern(gridIndex, config.cols));
                    cloneRow.appendChild(btn);
                } else {
                    const spacer = document.createElement('div');
                    spacer.className = 'clone-spacer';
                    cloneRow.appendChild(spacer);
                }
            }
            section.appendChild(cloneRow);

            container.appendChild(section);
        }

        function toggleCollapse(gridIndex) {
            const grid = grids.find(g => g.index === gridIndex);
            if (!grid) return;
            grid.collapsed = !grid.collapsed;
            const section = document.getElementById(`section-${gridIndex}`);
            const btn = document.getElementById(`collapse-${gridIndex}`);
            section.classList.toggle('collapsed', grid.collapsed);
            btn.innerHTML = `<span class="material-icons">${grid.collapsed ? 'expand_less' : 'expand_more'}</span>`;
        }

        function toggleMute(gridIndex) {
            const grid = grids.find(g => g.index === gridIndex);
            if (!grid) return;
            grid.muted = !grid.muted;
            const section = document.getElementById(`section-${gridIndex}`);
            const btn = document.getElementById(`mute-${gridIndex}`);
            section.classList.toggle('muted', grid.muted);
            btn.innerHTML = `<span class="material-icons">${grid.muted ? 'volume_off' : 'volume_up'}</span>`;
            btn.classList.toggle('active', grid.muted);
        }

        function clearTrack(gridIndex) {
            const grid = grids.find(g => g.index === gridIndex);
            if (!grid) return;
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    grid.data[row][col] = false;
                }
            }
            updateGridUI(gridIndex);
        }

        function highlightColumn(col) {
            if (hoveredColumn === col) return;
            clearColumnHighlight();
            hoveredColumn = col;
            document.querySelectorAll(`.cell[data-col="${col}"]`).forEach(cell => {
                cell.classList.add('hover-highlight');
            });
        }

        function clearColumnHighlight() {
            if (hoveredColumn < 0) return;
            document.querySelectorAll('.cell.hover-highlight').forEach(cell => {
                cell.classList.remove('hover-highlight');
            });
            hoveredColumn = -1;
        }

        function setCell(gridIndex, row, col, cell, value) {
            const grid = grids.find(g => g.index === gridIndex);
            if (!grid || grid.data[row][col] === value) return;
            grid.data[row][col] = value;
            cell.classList.toggle('active', value);
            if (value) {
                initAudio();
                const inst = instruments.find(i => i.id === grid.instrumentId);
                if (inst) playInstrument(inst, frequencies[row], 0.1);
            }
        }

        function updateInstrumentSelect(select, selectedId) {
            select.innerHTML = '';
            instruments.forEach(inst => {
                const option = document.createElement('option');
                option.value = inst.id;
                option.textContent = inst.name;
                if (inst.id === selectedId) option.selected = true;
                select.appendChild(option);
            });
        }

        function updateAllInstrumentSelects() {
            grids.forEach(grid => {
                const select = document.getElementById(`instrument-select-${grid.index}`);
                if (select) updateInstrumentSelect(select, grid.instrumentId);
            });
        }

        function removeGrid(gridIndex) {
            const idx = grids.findIndex(g => g.index === gridIndex);
            if (idx > -1) {
                grids.splice(idx, 1);
                document.getElementById(`section-${gridIndex}`).remove();
            }
        }

        function clonePattern(gridIndex, sourceCols) {
            const grid = grids.find(g => g.index === gridIndex);
            if (!grid) return;
            for (let row = 0; row < ROWS; row++) {
                for (let col = sourceCols; col < COLS; col++) {
                    grid.data[row][col] = grid.data[row][col % sourceCols];
                }
            }
            updateGridUI(gridIndex);
        }

        function updateGridUI(gridIndex) {
            const grid = grids.find(g => g.index === gridIndex);
            if (!grid) return;
            const matrix = document.getElementById(`matrix-${gridIndex}`);
            const cells = matrix.querySelectorAll('.cell');
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                cell.classList.toggle('active', grid.data[row][col]);
            });
        }

        function initAudio() {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playInstrument(inst, frequency, duration) {
            if (!audioContext) return;
            const now = audioContext.currentTime;
            const attack = inst.attack / 1000;
            const decay = inst.decay / 1000;
            const volume = inst.volume / 100 * 0.3;

            if (inst.type === 'drum-kick') { playKick(now, volume); return; }
            if (inst.type === 'drum-snare') { playSnare(now, volume); return; }
            if (inst.type === 'drum-hihat') { playHiHat(now, volume); return; }
            if (inst.type === 'drum-clap') { playClap(now, volume); return; }
            if (inst.type === 'drum-tom') { playTom(now, frequency, volume); return; }
            if (inst.type === 'noise') { playNoise(now, attack, decay, volume, inst.noiseAmount); return; }
            if (inst.type === 'fm') { playFM(inst, frequency, now, attack, decay, volume); return; }
            if (inst.type === 'pulse') { playPulse(inst, frequency, now, attack, decay, volume); return; }
            if (inst.type === 'custom' && inst.customWaveform) { playCustom(inst, frequency, now, attack, decay, volume); return; }

            // Standard oscillator types with optional noise
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = inst.type;
            oscillator.frequency.setValueAtTime(frequency, now);

            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + attack);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);

            oscillator.start(now);
            oscillator.stop(now + attack + decay + 0.1);

            // Add noise if specified
            if (inst.noiseAmount > 0) {
                const noiseVol = volume * (inst.noiseAmount / 100);
                playNoise(now, attack, decay, noiseVol, 0);
            }
        }

        function playKick(now, volume) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            gain.gain.setValueAtTime(volume, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            osc.start(now);
            osc.stop(now + 0.2);
        }

        function playSnare(now, volume) {
            const osc = audioContext.createOscillator();
            const oscGain = audioContext.createGain();
            osc.connect(oscGain);
            oscGain.connect(audioContext.destination);
            osc.frequency.setValueAtTime(200, now);
            oscGain.gain.setValueAtTime(volume * 0.5, now);
            oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);

            const bufferSize = audioContext.sampleRate * 0.1;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioContext.createBufferSource();
            const noiseGain = audioContext.createGain();
            noise.buffer = buffer;
            noise.connect(noiseGain);
            noiseGain.connect(audioContext.destination);
            noiseGain.gain.setValueAtTime(volume, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            noise.start(now);
        }

        function playHiHat(now, volume) {
            const bufferSize = audioContext.sampleRate * 0.05;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioContext.createBufferSource();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 7000;
            noise.buffer = buffer;
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(volume, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
            noise.start(now);
        }

        function playClap(now, volume) {
            for (let i = 0; i < 3; i++) {
                const bufferSize = audioContext.sampleRate * 0.02;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let j = 0; j < bufferSize; j++) data[j] = Math.random() * 2 - 1;
                const noise = audioContext.createBufferSource();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 2000;
                noise.buffer = buffer;
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                const offset = i * 0.01;
                gain.gain.setValueAtTime(volume * (1 - i * 0.2), now + offset);
                gain.gain.exponentialRampToValueAtTime(0.001, now + offset + 0.08);
                noise.start(now + offset);
            }
        }

        function playTom(now, frequency, volume) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);
            const baseFreq = Math.min(frequency, 200);
            osc.frequency.setValueAtTime(baseFreq * 1.5, now);
            osc.frequency.exponentialRampToValueAtTime(baseFreq, now + 0.1);
            gain.gain.setValueAtTime(volume, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
            osc.start(now);
            osc.stop(now + 0.15);
        }

        function playNoise(now, attack, decay, volume, extraNoise) {
            const bufferSize = audioContext.sampleRate * (attack + decay);
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioContext.createBufferSource();
            const gain = audioContext.createGain();
            noise.buffer = buffer;
            noise.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume, now + attack);
            gain.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);
            noise.start(now);
        }

        function playPulse(inst, frequency, now, attack, decay, volume) {
            const dutyCycle = (inst.dutyCycle || 50) / 100;
            const real = new Float32Array(64);
            const imag = new Float32Array(64);
            for (let i = 1; i < 64; i++) {
                imag[i] = (2 / (i * Math.PI)) * Math.sin(i * Math.PI * dutyCycle);
            }
            const wave = audioContext.createPeriodicWave(real, imag);
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.setPeriodicWave(wave);
            osc.frequency.setValueAtTime(frequency, now);
            osc.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume, now + attack);
            gain.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);
            osc.start(now);
            osc.stop(now + attack + decay + 0.1);

            // Add noise if specified
            if (inst.noiseAmount > 0) {
                const noiseVol = volume * (inst.noiseAmount / 100);
                playNoise(now, attack, decay, noiseVol, 0);
            }
        }

        function playFM(inst, frequency, now, attack, decay, volume) {
            const modRatio = inst.fmRatio || 2;
            const modDepth = inst.fmDepth || 100;
            const carrier = audioContext.createOscillator();
            const modulator = audioContext.createOscillator();
            const modGain = audioContext.createGain();
            const gainNode = audioContext.createGain();
            modulator.frequency.setValueAtTime(frequency * modRatio, now);
            modGain.gain.setValueAtTime(modDepth, now);
            modulator.connect(modGain);
            modGain.connect(carrier.frequency);
            carrier.frequency.setValueAtTime(frequency, now);
            carrier.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + attack);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);
            carrier.start(now);
            modulator.start(now);
            carrier.stop(now + attack + decay + 0.1);
            modulator.stop(now + attack + decay + 0.1);

            // Add noise if specified
            if (inst.noiseAmount > 0) {
                const noiseVol = volume * (inst.noiseAmount / 100);
                playNoise(now, attack, decay, noiseVol, 0);
            }
        }

        function playCustom(inst, frequency, now, attack, decay, volume) {
            const waveform = inst.customWaveform;
            const real = new Float32Array(waveform.length);
            const imag = new Float32Array(waveform.length);
            for (let i = 0; i < waveform.length; i++) {
                imag[i] = waveform[i];
            }
            const wave = audioContext.createPeriodicWave(real, imag, { disableNormalization: false });
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.setPeriodicWave(wave);
            oscillator.frequency.setValueAtTime(frequency, now);
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(volume, now + attack);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);
            oscillator.start(now);
            oscillator.stop(now + attack + decay + 0.1);

            // Add noise if specified
            if (inst.noiseAmount > 0) {
                const noiseVol = volume * (inst.noiseAmount / 100);
                playNoise(now, attack, decay, noiseVol, 0);
            }
        }

        function playColumn(col) {
            document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('column-highlight'));
            grids.forEach(grid => {
                if (grid.muted) return;
                const matrix = document.getElementById(`matrix-${grid.index}`);
                if (!matrix) return;
                const cells = matrix.querySelectorAll('.cell');
                const inst = instruments.find(i => i.id === grid.instrumentId);
                for (let row = 0; row < ROWS; row++) {
                    const cellIndex = row * COLS + col;
                    const cell = cells[cellIndex];
                    if (cell) {
                        cell.classList.add('column-highlight');
                        if (grid.data[row][col] && inst) playInstrument(inst, frequencies[row], 0.5);
                    }
                }
            });
        }

        function togglePlay() {
            const playBtn = document.getElementById('playBtn');
            if (isPlaying) {
                isPlaying = false;
                clearInterval(intervalId);
                playBtn.textContent = 'Play';
                playBtn.classList.remove('active');
                document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('column-highlight'));
            } else {
                initAudio();
                isPlaying = true;
                playBtn.textContent = 'Stop';
                playBtn.classList.add('active');
                const intervalMs = (60 / tempo) * 1000 / 4;
                intervalId = setInterval(() => {
                    playColumn(currentColumn);
                    currentColumn = (currentColumn + 1) % COLS;
                }, intervalMs);
            }
        }

        function clearAllGrids() {
            grids.forEach(grid => {
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        grid.data[row][col] = false;
                    }
                }
                updateGridUI(grid.index);
            });
        }

        function updateTempo(value) {
            tempo = parseInt(value);
            if (isPlaying) {
                clearInterval(intervalId);
                const intervalMs = (60 / tempo) * 1000 / 4;
                intervalId = setInterval(() => {
                    playColumn(currentColumn);
                    currentColumn = (currentColumn + 1) % COLS;
                }, intervalMs);
            }
        }

        function renderInstrumentList() {
            const list = document.getElementById('instrumentList');
            list.innerHTML = '';
            instruments.forEach(inst => {
                const item = document.createElement('div');
                item.className = 'instrument-item' + (inst.id === selectedInstrumentId ? ' selected' : '');
                item.innerHTML = `
                    <span>${inst.name}</span>
                    <div class="instrument-item-actions">
                        <button class="instrument-item-btn" onclick="editInstrument('${inst.id}')">Edit</button>
                        ${!inst.isPreset ? `<button class="instrument-item-btn" onclick="deleteInstrument('${inst.id}')">×</button>` : ''}
                    </div>
                `;
                item.addEventListener('click', (e) => {
                    if (e.target.tagName !== 'BUTTON') selectInstrument(inst.id);
                });
                list.appendChild(item);
            });
        }

        function selectInstrument(id) {
            selectedInstrumentId = id;
            renderInstrumentList();
        }

        function editInstrument(id) {
            const inst = instruments.find(i => i.id === id);
            if (!inst) return;

            editingInstrument = JSON.parse(JSON.stringify(inst));
            document.getElementById('waveEditorSection').style.display = 'block';
            document.getElementById('instrumentName').value = inst.name;

            // Set wave type
            document.querySelectorAll('.wave-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === inst.type);
            });

            // Set parameters
            document.getElementById('attack').value = inst.attack;
            document.getElementById('attackValue').textContent = inst.attack + 'ms';
            document.getElementById('decay').value = inst.decay;
            document.getElementById('decayValue').textContent = inst.decay + 'ms';
            document.getElementById('volume').value = inst.volume;
            document.getElementById('volumeValue').textContent = inst.volume + '%';
            document.getElementById('noiseAmount').value = inst.noiseAmount || 0;
            document.getElementById('noiseAmountValue').textContent = (inst.noiseAmount || 0) + '%';

            // Pulse params
            if (inst.type === 'pulse') {
                document.getElementById('pulseParams').style.display = 'block';
                document.getElementById('dutyCycle').value = inst.dutyCycle || 50;
                document.getElementById('dutyCycleValue').textContent = (inst.dutyCycle || 50) + '%';
            } else {
                document.getElementById('pulseParams').style.display = 'none';
            }

            // FM params
            if (inst.type === 'fm') {
                document.getElementById('fmParams').style.display = 'block';
                document.getElementById('fmRatio').value = inst.fmRatio || 2;
                document.getElementById('fmRatioValue').textContent = inst.fmRatio || 2;
                document.getElementById('fmDepth').value = inst.fmDepth || 100;
                document.getElementById('fmDepthValue').textContent = inst.fmDepth || 100;
            } else {
                document.getElementById('fmParams').style.display = 'none';
            }

            // Custom waveform
            if (inst.type === 'custom' && inst.customWaveform) {
                customWaveform = [...inst.customWaveform];
            } else {
                customWaveform = null;
            }

            drawWaveform();
        }

        function deleteInstrument(id) {
            const inst = instruments.find(i => i.id === id);
            if (!inst || inst.isPreset) return;
            instruments = instruments.filter(i => i.id !== id);
            renderInstrumentList();
            updateAllInstrumentSelects();
            saveInstruments();
        }

        function createNewInstrument() {
            const id = 'inst_' + Date.now();
            editingInstrument = {
                id: id,
                name: 'New Instrument',
                type: 'sine',
                noiseAmount: 0,
                attack: 10,
                decay: 300,
                volume: 50,
                isPreset: false
            };

            document.getElementById('waveEditorSection').style.display = 'block';
            document.getElementById('instrumentName').value = 'New Instrument';

            document.querySelectorAll('.wave-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === 'sine');
            });

            document.getElementById('attack').value = 10;
            document.getElementById('attackValue').textContent = '10ms';
            document.getElementById('decay').value = 300;
            document.getElementById('decayValue').textContent = '300ms';
            document.getElementById('volume').value = 50;
            document.getElementById('volumeValue').textContent = '50%';
            document.getElementById('noiseAmount').value = 0;
            document.getElementById('noiseAmountValue').textContent = '0%';
            document.getElementById('pulseParams').style.display = 'none';
            document.getElementById('fmParams').style.display = 'none';

            customWaveform = null;
            drawWaveform();
        }

        function getUniqueName(baseName) {
            let name = baseName;
            let counter = 2;
            while (instruments.some(i => i.name.toLowerCase() === name.toLowerCase())) {
                name = `${baseName} ${counter++}`;
            }
            return name;
        }

        function saveCurrentInstrument() {
            if (!editingInstrument) return;

            const name = document.getElementById('instrumentName').value.trim() || 'Unnamed';
            editingInstrument.name = name;
            editingInstrument.noiseAmount = parseInt(document.getElementById('noiseAmount').value);
            editingInstrument.attack = parseInt(document.getElementById('attack').value);
            editingInstrument.decay = parseInt(document.getElementById('decay').value);
            editingInstrument.volume = parseInt(document.getElementById('volume').value);

            if (editingInstrument.type === 'pulse') {
                editingInstrument.dutyCycle = parseInt(document.getElementById('dutyCycle').value);
            }

            if (editingInstrument.type === 'fm') {
                editingInstrument.fmRatio = parseInt(document.getElementById('fmRatio').value);
                editingInstrument.fmDepth = parseInt(document.getElementById('fmDepth').value);
            }

            if (editingInstrument.type === 'custom' && customWaveform) {
                editingInstrument.customWaveform = [...customWaveform];
            }

            const existingIdx = instruments.findIndex(i => i.id === editingInstrument.id);
            const isEditingPreset = existingIdx > -1 && instruments[existingIdx].isPreset;

            // Force "Save As" for presets
            if (isEditingPreset) {
                const suggestedName = getUniqueName(name);
                document.getElementById('saveAsName').value = suggestedName;
                document.getElementById('saveModalTitle').textContent = 'Save As New';
                document.getElementById('saveModalText').textContent = 'Presets cannot be overwritten. Save as a new instrument:';
                document.getElementById('saveModal').style.display = 'flex';

                document.getElementById('confirmSaveBtn').onclick = () => {
                    const newName = document.getElementById('saveAsName').value.trim() || 'Unnamed';
                    editingInstrument.id = 'inst_' + Date.now();
                    editingInstrument.name = getUniqueName(newName);
                    editingInstrument.isPreset = false;
                    instruments.push({ ...editingInstrument });
                    finishSave();
                };
                document.getElementById('cancelSaveBtn').onclick = () => {
                    document.getElementById('saveModal').style.display = 'none';
                };
            } else if (existingIdx > -1) {
                // Updating existing custom instrument - check for name conflicts
                const nameExists = instruments.some(i => i.name.toLowerCase() === name.toLowerCase() && i.id !== editingInstrument.id);
                if (nameExists) {
                    editingInstrument.name = getUniqueName(name);
                }
                instruments[existingIdx] = { ...editingInstrument };
                finishSave();
            } else {
                // New instrument - ensure unique name
                editingInstrument.name = getUniqueName(name);
                editingInstrument.isPreset = false;
                instruments.push({ ...editingInstrument });
                finishSave();
            }
        }

        function finishSave() {
            document.getElementById('saveModal').style.display = 'none';
            renderInstrumentList();
            updateAllInstrumentSelects();
            saveInstruments();
            document.getElementById('waveEditorSection').style.display = 'none';
            editingInstrument = null;
        }

        // Wave canvas for custom waveform drawing
        function setupWaveCanvas() {
            const canvas = document.getElementById('waveCanvas');

            canvas.addEventListener('mousedown', (e) => {
                if (editingInstrument && editingInstrument.type === 'custom') {
                    isDrawing = true;
                    if (!customWaveform) {
                        customWaveform = new Array(64).fill(0);
                    }
                    drawPoint(e);
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDrawing) drawPoint(e);
            });

            canvas.addEventListener('mouseup', () => isDrawing = false);
            canvas.addEventListener('mouseleave', () => isDrawing = false);

            function drawPoint(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const idx = Math.floor(x / canvas.width * 64);
                const val = 1 - (y / canvas.height) * 2;

                if (idx >= 0 && idx < 64) {
                    customWaveform[idx] = Math.max(-1, Math.min(1, val));
                    drawWaveform();
                }
            }
        }

        function drawWaveform() {
            const canvas = document.getElementById('waveCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#222';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();

            if (!editingInstrument) return;

            ctx.strokeStyle = '#00d4aa';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const samples = 64;
            for (let i = 0; i < samples; i++) {
                const x = (i / samples) * canvas.width;
                let y;

                if (editingInstrument.type === 'custom' && customWaveform) {
                    y = canvas.height / 2 - customWaveform[i] * (canvas.height / 2 - 5);
                } else {
                    const t = i / samples * Math.PI * 2;
                    let val = 0;

                    switch (editingInstrument.type) {
                        case 'sine':
                            val = Math.sin(t);
                            break;
                        case 'square':
                            val = Math.sin(t) > 0 ? 1 : -1;
                            break;
                        case 'triangle':
                            val = Math.asin(Math.sin(t)) * 2 / Math.PI;
                            break;
                        case 'sawtooth':
                            val = (t % (Math.PI * 2)) / Math.PI - 1;
                            break;
                        case 'pulse':
                            const duty = (editingInstrument.dutyCycle || 50) / 100;
                            val = (t % (Math.PI * 2)) < (Math.PI * 2 * duty) ? 1 : -1;
                            break;
                        case 'noise':
                            val = Math.random() * 2 - 1;
                            break;
                        case 'fm':
                            const ratio = editingInstrument.fmRatio || 2;
                            const depth = (editingInstrument.fmDepth || 100) / 500;
                            val = Math.sin(t + depth * Math.sin(t * ratio));
                            break;
                    }

                    y = canvas.height / 2 - val * (canvas.height / 2 - 5);
                }

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }

            ctx.stroke();
        }

        // Save/Load instruments
        function saveInstruments() {
            const custom = instruments.filter(i => !i.isPreset);
            localStorage.setItem('tonematrix-instruments', JSON.stringify(custom));
        }

        function loadInstruments() {
            const saved = localStorage.getItem('tonematrix-instruments');
            if (saved) {
                try {
                    const loaded = JSON.parse(saved);
                    // Add loaded custom instruments after presets
                    loaded.forEach(inst => {
                        if (!instruments.some(i => i.id === inst.id)) {
                            inst.isPreset = false;
                            instruments.push(inst);
                        }
                    });
                } catch (e) {
                    console.error('Failed to load instruments', e);
                }
            }
        }

        function exportInstruments() {
            const data = JSON.stringify(instruments, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tonematrix-instruments.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importInstruments(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (Array.isArray(imported)) {
                        // Keep presets, add imported with unique names
                        const presets = instruments.filter(i => i.isPreset);
                        const newInstruments = [];
                        imported.forEach(inst => {
                            inst.name = getUniqueName(inst.name);
                            inst.isPreset = false;
                            newInstruments.push(inst);
                        });
                        instruments = [...presets, ...newInstruments];
                        saveInstruments();
                        renderInstrumentList();
                        updateAllInstrumentSelects();
                    }
                } catch (err) {
                    alert('Invalid instruments file');
                }
            };
            reader.readAsText(file);
        }

        function setupEventListeners() {
            document.getElementById('playBtn').addEventListener('click', togglePlay);
            document.getElementById('clearBtn').addEventListener('click', clearAllGrids);
            document.getElementById('tempo').addEventListener('change', (e) => updateTempo(e.target.value));
            document.getElementById('addGridBtn').addEventListener('click', addGrid);
            document.getElementById('newInstrumentBtn').addEventListener('click', createNewInstrument);
            document.getElementById('saveInstrumentBtn').addEventListener('click', saveCurrentInstrument);
            document.getElementById('exportInstrumentsBtn').addEventListener('click', exportInstruments);
            document.getElementById('importInstrumentsBtn').addEventListener('click', () => document.getElementById('importFile').click());
            document.getElementById('importFile').addEventListener('change', (e) => { if (e.target.files[0]) importInstruments(e.target.files[0]); });

            // Wave type buttons
            document.querySelectorAll('.wave-type-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (!editingInstrument) return;

                    document.querySelectorAll('.wave-type-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    editingInstrument.type = btn.dataset.type;

                    document.getElementById('pulseParams').style.display = btn.dataset.type === 'pulse' ? 'block' : 'none';
                    document.getElementById('fmParams').style.display = btn.dataset.type === 'fm' ? 'block' : 'none';

                    if (btn.dataset.type === 'custom' && !customWaveform) {
                        customWaveform = new Array(64).fill(0);
                    }

                    drawWaveform();
                });
            });

            // Parameter sliders
            document.getElementById('attack').addEventListener('input', (e) => {
                document.getElementById('attackValue').textContent = e.target.value + 'ms';
            });
            document.getElementById('decay').addEventListener('input', (e) => {
                document.getElementById('decayValue').textContent = e.target.value + 'ms';
            });
            document.getElementById('volume').addEventListener('input', (e) => {
                document.getElementById('volumeValue').textContent = e.target.value + '%';
            });
            document.getElementById('noiseAmount').addEventListener('input', (e) => {
                document.getElementById('noiseAmountValue').textContent = e.target.value + '%';
            });
            document.getElementById('dutyCycle').addEventListener('input', (e) => {
                document.getElementById('dutyCycleValue').textContent = e.target.value + '%';
                if (editingInstrument) {
                    editingInstrument.dutyCycle = parseInt(e.target.value);
                    drawWaveform();
                }
            });
            document.getElementById('fmRatio').addEventListener('input', (e) => {
                document.getElementById('fmRatioValue').textContent = e.target.value;
                if (editingInstrument) {
                    editingInstrument.fmRatio = parseInt(e.target.value);
                    drawWaveform();
                }
            });
            document.getElementById('fmDepth').addEventListener('input', (e) => {
                document.getElementById('fmDepthValue').textContent = e.target.value;
                if (editingInstrument) {
                    editingInstrument.fmDepth = parseInt(e.target.value);
                    drawWaveform();
                }
            });

            // Spacebar
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && e.target.tagName !== 'INPUT') {
                    e.preventDefault();
                    togglePlay();
                }
            });

            document.addEventListener('mouseup', () => {
                paintMode = null;
                paintGridIndex = null;
            });

            // Modal close on background click
            document.getElementById('saveModal').addEventListener('click', (e) => {
                if (e.target.id === 'saveModal') {
                    document.getElementById('saveModal').style.display = 'none';
                }
            });
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
